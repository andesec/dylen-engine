from __future__ import annotations

import argparse
import importlib
import os
import subprocess
import sys
from pathlib import Path


def _repo_root() -> Path:
  """Resolve the repository root so paths are stable from any working directory."""
  return Path(__file__).resolve().parents[1]


def _require_env(name: str) -> str:
  """Read required environment variables so migrations never target the wrong DB."""
  value = os.getenv(name, "").strip()
  if not value:
    # Keep the failure actionable so developers don't silently generate migrations against the wrong target.
    message = f"{name} is required (set it in your shell or add it to .env; see .env.example)."
    if name == "DYLEN_ALLOWED_ORIGINS":
      message = message + " Example: DYLEN_ALLOWED_ORIGINS=http://localhost:3000"

    raise RuntimeError(message)

  return value


def _require_import(name: str) -> None:
  """Fail fast when required runtime dependencies are missing from the active interpreter."""
  # Ensure the interpreter used for Alembic has the DB driver installed.
  try:
    importlib.import_module(name)
  except ModuleNotFoundError as exc:
    raise RuntimeError(f"Missing dependency {name!r} in {sys.executable}. Run: uv sync --all-extras") from exc


def _run(command: list[str], *, env: dict[str, str]) -> None:
  """Run a command and fail fast with a clear error path."""
  subprocess.run(command, check=True, cwd=_repo_root(), env=env)


def _latest_revision_path(*, versions_dir: Path) -> Path | None:
  """Return the most recently modified migration file for quick developer navigation."""
  candidates = [path for path in versions_dir.glob("*.py") if path.is_file()]
  if not candidates:
    return None

  return max(candidates, key=lambda path: path.stat().st_mtime)


def _is_empty_autogenerated_migration(*, path: Path) -> bool:
  """Detect empty Alembic autogenerate output so we don't create noisy revisions."""
  text = path.read_text(encoding="utf-8")
  # Alembic autogenerate uses `pass` when it detects no diffs.
  if "def upgrade() -> None:" not in text:
    return False

  if "def downgrade() -> None:" not in text:
    return False

  return "def upgrade() -> None:" in text and "\n    pass\n" in text and "def downgrade() -> None:" in text and "\n    pass\n" in text


def main() -> None:
  """Autogenerate a migration, lint it, and apply it locally so devs can move on safely."""
  parser = argparse.ArgumentParser(description="Generate and validate an Alembic migration for local development.")
  parser.add_argument("--message", required=True, help="Migration message, e.g. 'add_user_last_seen'.")
  args = parser.parse_args()

  # Require env vars explicitly to prevent accidentally targeting an unintended database.
  _require_env("DYLEN_PG_DSN")
  _require_env("DYLEN_ALLOWED_ORIGINS")
  # Ensure the runtime driver is available before running Alembic.
  _require_import("asyncpg")
  repo_root = _repo_root()
  alembic_ini = repo_root / "alembic.ini"
  versions_dir = repo_root / "alembic" / "versions"

  env = os.environ.copy()
  # Ensure PYTHONPATH includes the repo root so 'app' is importable
  env["PYTHONPATH"] = str(repo_root) + (os.pathsep + env["PYTHONPATH"] if env.get("PYTHONPATH") else "")

  # Ensure the local DB is at head before generating autogenerate diffs.
  _run([sys.executable, "-m", "alembic", "-c", str(alembic_ini), "upgrade", "head"], env=env)

  # Generate a migration skeleton from SQLAlchemy metadata differences.
  _run([sys.executable, "-m", "alembic", "-c", str(alembic_ini), "revision", "--autogenerate", "-m", args.message], env=env)
  latest = _latest_revision_path(versions_dir=versions_dir)
  if not latest:
    raise RuntimeError("Alembic did not generate a migration file (unexpected).")

  # Prevent empty migrations from being created (they fail lint and create PR noise).
  if _is_empty_autogenerated_migration(path=latest):
    # Delete the file so developers don't accidentally commit empty revisions.
    latest.unlink()
    print("No schema changes detected; removed empty autogenerated migration.")
    return

  print(f"Generated migration: {latest}")

  # Lint before applying so unsafe patterns fail fast in dev.
  _run([sys.executable, "scripts/db_migration_lint.py"], env=env)
  _run([sys.executable, "scripts/db_check_heads.py"], env=env)

  # Apply the new revision and verify metadata drift stays clean.
  _run([sys.executable, "-m", "alembic", "-c", str(alembic_ini), "upgrade", "head"], env=env)
  _run([sys.executable, "scripts/db_check_drift.py"], env=env)

  print("OK: Migration generated, linted, applied, and drift-checked.")


if __name__ == "__main__":
  main()

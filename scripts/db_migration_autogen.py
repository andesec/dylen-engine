from __future__ import annotations

import argparse
import importlib
import os
import re
import subprocess
import sys
from collections.abc import Iterator
from contextlib import contextmanager
from pathlib import Path

# Ensure repo root is on sys.path so local imports work when invoked directly.
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))

from scripts.db_migration_guard import guard_migration_file


def _repo_root() -> Path:
  """Resolve the repository root so paths are stable from any working directory."""
  return Path(__file__).resolve().parents[1]


@contextmanager
def _temporary_environ(*, updates: dict[str, str]) -> Iterator[None]:
  """Temporarily apply environment updates so subprocesses can inherit them safely."""
  # Snapshot current values so we can restore them even if subprocess execution fails.
  prior: dict[str, str | None] = {key: os.environ.get(key) for key in updates}
  # Apply requested updates in-place so subprocess.run inherits them without passing a tainted env mapping.
  os.environ.update(updates)
  try:
    yield
  finally:
    # Restore the original environment to avoid leaking state into the parent shell/session.
    for key, value in prior.items():
      if value is None:
        os.environ.pop(key, None)
        continue

      os.environ[key] = value


def _require_env(name: str) -> str:
  """Read required environment variables so migrations never target the wrong DB."""
  value = os.getenv(name, "").strip()
  if not value:
    # Keep the failure actionable so developers don't silently generate migrations against the wrong target.
    message = f"{name} is required (set it in your shell or add it to .env; see .env.example)."
    if name == "DYLEN_ALLOWED_ORIGINS":
      message = message + " Example: DYLEN_ALLOWED_ORIGINS=http://localhost:3000"

    raise RuntimeError(message)

  return value


def _require_import(name: str) -> None:
  """Fail fast when required runtime dependencies are missing from the active interpreter."""
  # Ensure the interpreter used for Alembic has the DB driver installed.
  try:
    importlib.import_module(name)
  except ModuleNotFoundError as exc:
    raise RuntimeError(f"Missing dependency {name!r} in {sys.executable}. Run: uv sync --all-extras") from exc


def _run(command: list[str]) -> None:
  """Run a command and fail fast with a clear error path."""
  subprocess.run(command, check=True, cwd=_repo_root())


def _latest_revision_path(*, versions_dir: Path) -> Path | None:
  """Return the most recently modified migration file for quick developer navigation."""
  candidates = [path for path in versions_dir.glob("*.py") if path.is_file()]
  if not candidates:
    return None

  return max(candidates, key=lambda path: path.stat().st_mtime)


def _extract_revision_id(*, path: Path) -> str:
  """Extract the Alembic revision id from a migration file."""
  # Parse the revision id from the Alembic header for seed script naming.
  text = path.read_text(encoding="utf-8")
  match = re.search(r"^Revision ID:\s*(?P<rev>[0-9a-f]+)\s*$", text, re.MULTILINE)
  if not match:
    raise RuntimeError(f"Unable to parse Revision ID from {path}.")

  return match.group("rev")


def _ensure_seed_script(*, revision: str, repo_root: Path) -> None:
  """Create an empty seed script for the revision if missing."""
  # Build the seed script path from the repo root.
  seeds_dir = repo_root / "scripts" / "seeds"
  seed_path = seeds_dir / f"{revision}.py"
  if seed_path.exists():
    return

  # Ensure the seed scripts directory exists before writing.
  seeds_dir.mkdir(parents=True, exist_ok=True)
  seed_path.write_text(
    f'"""Seed data for migration {revision}."""\n\n'
    "from __future__ import annotations\n\n"
    "from sqlalchemy.ext.asyncio import AsyncConnection\n\n"
    "async def seed(connection: AsyncConnection) -> None:\n"
    '  """Apply seed data for this migration (intentionally empty)."""\n'
    "  # No seed data is required for this revision.\n"
    "  return\n",
    encoding="utf-8",
  )


def _is_empty_autogenerated_migration(*, path: Path) -> bool:
  """Detect empty Alembic autogenerate output so we don't create noisy revisions."""
  text = path.read_text(encoding="utf-8")
  # Alembic autogenerate uses `pass` when it detects no diffs.
  if "def upgrade() -> None:" not in text:
    return False

  if "def downgrade() -> None:" not in text:
    return False

  return "def upgrade() -> None:" in text and "\n    pass\n" in text and "def downgrade() -> None:" in text and "\n    pass\n" in text


def main() -> None:
  """Autogenerate a migration, lint it, and apply it locally so devs can move on safely."""
  parser = argparse.ArgumentParser(description="Generate and validate an Alembic migration for local development.")
  parser.add_argument("--message", required=True, help="Migration message, e.g. 'add_user_last_seen'.")
  args = parser.parse_args()

  # Require env vars explicitly to prevent accidentally targeting an unintended database.
  _require_env("DYLEN_PG_DSN")
  # Ensure the runtime driver is available before running Alembic.
  _require_import("asyncpg")
  repo_root = _repo_root()
  alembic_ini = repo_root / "alembic.ini"
  versions_dir = repo_root / "alembic" / "versions"

  # Ensure PYTHONPATH includes the repo root so 'app' is importable during Alembic runs.
  updates = {"PYTHONPATH": str(repo_root) + (os.pathsep + os.environ["PYTHONPATH"] if os.environ.get("PYTHONPATH") else "")}
  with _temporary_environ(updates=updates):
    # Ensure the local DB is at head before generating autogenerate diffs.
    _run([sys.executable, "-m", "alembic", "-c", str(alembic_ini), "upgrade", "head"])

    # Generate a migration skeleton from SQLAlchemy metadata differences.
    _run([sys.executable, "-m", "alembic", "-c", str(alembic_ini), "revision", "--autogenerate", "-m", args.message])
    # Locate the newest migration file to apply guard transformations.
    latest = _latest_revision_path(versions_dir=versions_dir)
    if not latest:
      raise RuntimeError("Alembic did not generate a migration file (unexpected).")

    # Guard DDL operations so the migration is idempotent.
    guard_migration_file(path=latest)
    # Create a stub seed script for the new revision.
    revision_id = _extract_revision_id(path=latest)
    _ensure_seed_script(revision=revision_id, repo_root=repo_root)

    # Prevent empty migrations from being created (they fail lint and create PR noise).
    if _is_empty_autogenerated_migration(path=latest):
      # Delete the file so developers don't accidentally commit empty revisions.
      latest.unlink()
      print("No schema changes detected; removed empty autogenerated migration.")
      return

    print(f"Generated migration: {latest}")

    # Lint and linear-history checks before applying so unsafe patterns fail fast in dev.
    _run([sys.executable, "scripts/db_migration_lint.py"])
    _run([sys.executable, "scripts/db_check_heads.py"])
    _run([sys.executable, "scripts/db_check_linear_history.py", "--fix"])

    # Apply the new revision and verify metadata drift stays clean.
    _run([sys.executable, "-m", "alembic", "-c", str(alembic_ini), "upgrade", "head"])
    _run([sys.executable, "scripts/db_check_drift.py"])

  print("OK: Migration generated, linted, applied, and drift-checked.")


if __name__ == "__main__":
  main()

#!/usr/bin/env bash
set -euo pipefail

if [[ "${SKIP_GIT_MIGRATION_HOOK:-}" == "1" ]]; then
  exit 0
fi

repo_root="$(git rev-parse --show-toplevel)"
cd "$repo_root"

git_add_migration_versions() {
  # Avoid failing commits when the glob matches no files.
  shopt -s nullglob
  files=(alembic/versions/*.py)
  shopt -u nullglob
  if (( ${#files[@]} > 0 )); then
    git add "${files[@]}"
  fi
}

is_merge_migration() {
  # Ignore Alembic "merge heads" revisions in the one-migration rule.
  # These revisions are empty by design and exist only to reconcile branches.
  local path="$1"
  if [[ "$path" != alembic/versions/*.py ]]; then
    return 1
  fi

  # Prefer staged contents so the hook reflects what is being committed.
  local text=""
  if text="$(git show ":$path" 2>/dev/null)"; then
    :
  else
    text="$(cat "$path" 2>/dev/null || true)"
  fi

  if [[ -z "$text" ]]; then
    return 1
  fi

  # Match common merge revision signals without executing any code.
  # Accept merge revisions even without '# empty: allow' so Alembic merge output works out-of-the-box.
  # Prefer the down_revision tuple pattern to avoid exempting accidental empty migrations.
  if [[ "$text" != *"merge heads"* && "$text" != *"Revision ID: merge"* && "$text" != *"revision = \"merge"* ]]; then
    if ! grep -Eq 'down_revision[[:space:]]*:[^=]*=[[:space:]]*\\(.*"[^"]+".*,"[^"]+".*\\)' <<<"$text"; then
      return 1
    fi
  fi

  # Merge revisions should not contain schema operations.
  if [[ "$text" == *"op."* ]]; then
    return 1
  fi

  return 0
}

staged_changes="$(git diff --cached --name-status)"
if [[ -z "$staged_changes" ]]; then
  exit 0
fi

# Prevent modification of existing migration files and seed scripts from base branch
base_ref="${MIGRATION_BASE_REF:-main}"
base_target="origin/${base_ref}"
if git rev-parse --verify "$base_target" >/dev/null 2>&1; then
  merge_base_ref="$(git merge-base HEAD "$base_target")"
  
  while IFS=$'\t' read -r status path_a path_b; do
    # Only check modifications (M) and renames (R), not additions (A)
    if [[ "$status" != "M" && "$status" != R* ]]; then
      continue
    fi
    
    # Check if modifying an existing migration file from base
    if [[ "$path_a" == alembic/versions/*.py ]]; then
      if git ls-tree -r --name-only "$merge_base_ref" "$path_a" >/dev/null 2>&1; then
        echo "ERROR: Cannot modify existing migration file: $path_a"
        echo "Migrations must flow forward. Create a new migration instead:"
        echo "  make migration-auto m=\"description_of_change\""
        exit 1
      fi
    fi
    
    # Check if modifying an existing seed script from base
    if [[ "$path_a" == scripts/seeds/*.py ]]; then
      if git ls-tree -r --name-only "$merge_base_ref" "$path_a" >/dev/null 2>&1; then
        echo "ERROR: Cannot modify existing seed script: $path_a"
        echo "Seed scripts should not be modified after creation. Create a new migration with a new seed script instead."
        exit 1
      fi
    fi
  done <<< "$staged_changes"
fi

schema_changed="0"
while IFS=$'\t' read -r status path_a path_b; do
  # Ignore renames/moves; they don't imply schema semantics changed.
  if [[ "$status" == R* ]]; then
    continue
  fi

  # Skip seed scripts - they're data changes, not schema changes
  if [[ "$path_a" == scripts/seeds/* ]]; then
    continue
  fi

  # Check if schema files have actual SQLAlchemy model changes
  if [[ "$path_a" == app/schema/* ]]; then
    # Get the diff for this file to check for actual schema changes
    diff_content="$(git diff --cached "$path_a" 2>/dev/null || true)"
    
    # Look for SQLAlchemy schema-defining patterns:
    # - Column(...
    # - Table(...
    # - Index(...
    # - ForeignKey(...
    # - UniqueConstraint(...
    # - CheckConstraint(...
    # Ignore imports, comments, and non-schema code
    if echo "$diff_content" | grep -E '^\+.*\b(Column|Table|Index|ForeignKey|UniqueConstraint|CheckConstraint|PrimaryKeyConstraint)\s*\(' >/dev/null 2>&1; then
      schema_changed="1"
      break
    fi
    
    # Also check for removals of schema elements
    if echo "$diff_content" | grep -E '^-.*\b(Column|Table|Index|ForeignKey|UniqueConstraint|CheckConstraint|PrimaryKeyConstraint)\s*\(' >/dev/null 2>&1; then
      schema_changed="1"
      break
    fi
  fi
done <<< "$staged_changes"

if [[ "$schema_changed" != "1" ]]; then
  exit 0
fi

base_ref="${MIGRATION_BASE_REF:-main}"
base_target="origin/${base_ref}"
# If the PR base has no migrations yet (bootstrap / repo move), skip enforcement here.
if git rev-parse --verify "$base_target" >/dev/null 2>&1; then
  merge_base_ref="$(git merge-base HEAD "$base_target")"
  base_migrations="$(git ls-tree -r --name-only "$merge_base_ref" alembic/versions 2>/dev/null || true)"
  if [[ -z "$base_migrations" ]]; then
    base_migrations="$(git ls-tree -r --name-only "$merge_base_ref" dylen-engine/alembic/versions 2>/dev/null || true)"
  fi
  if [[ -z "$base_migrations" ]]; then
    echo "WARN: $base_target has no migrations at merge-base ($merge_base_ref); skipping migration enforcement for this commit."
    exit 0
  fi
fi

migration_count="0"
while IFS=$'\t' read -r status path_a path_b; do
  # Count actual new/modified migration files. For renames, only count when the
  # content changed substantially (layout moves often show as R99/R100 and should
  # not be treated as "multiple migrations" for the one-migration rule).
  if [[ "$status" == R* ]]; then
    similarity="${status#R}"
    if [[ "$path_a" == alembic/versions/*.py || "${path_b:-}" == alembic/versions/*.py ]]; then
      if [[ "$similarity" =~ ^[0-9]+$ ]] && (( 10#$similarity < 95 )); then
        migration_count="$((migration_count + 1))"
      fi
    fi
    continue
  fi

  if [[ "$status" != "A" && "$status" != "M" ]]; then
    continue
  fi

  if [[ "$path_a" == alembic/versions/*.py ]]; then
    if is_merge_migration "$path_a"; then
      continue
    fi
    migration_count="$((migration_count + 1))"
  fi
done <<< "$staged_changes"

if [[ "$migration_count" -eq 0 ]]; then
  if [[ "${DYLEN_AUTO_MIGRATIONS:-}" == "1" ]]; then
    message="auto_migration_$(date +%Y%m%d_%H%M%S)"
    make migration-auto "m=$message"
    git_add_migration_versions
  else
    echo "ERROR: Schema changes are staged without a migration file staged."
    echo "Run: make migration-auto m=\"short_description\""
    echo "Or set DYLEN_AUTO_MIGRATIONS=1 to auto-generate during commit."
    exit 1
  fi
fi

python3 scripts/db_migration_lint.py
python3 scripts/db_check_heads.py
# Normalize Create Date ordering before strict checks so commit-time behavior
# matches migration-auto generation flow.
python3 scripts/db_check_linear_history.py --fix
git_add_migration_versions
# Enforce linear history and Create Date ordering for migrations after autofix.
python3 scripts/db_check_linear_history.py

if [[ "${DYLEN_MIGRATION_HOOK_STRICT:-}" == "1" ]]; then
  if [[ -n "${DYLEN_PG_DSN:-}" || -n "${DGS_PG_DSN:-}" ]]; then
    make db-check-drift
    make db-check-seed-data
  else
    echo "WARN: DYLEN_PG_DSN (or DGS_PG_DSN) not set; skipping drift/seed checks."
  fi
fi
